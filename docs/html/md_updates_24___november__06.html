<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan Renderer: November 06 - First Commit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Vulkan Renderer<span id="projectnumber">&#160;v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">November 06 - First Commit</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md9"></a> This is the first update report. I've written a couple of classes that make up the base of this project. From here on out I'll start writing more vulkan code. Next up is device and surface creation.</p>
<p>In the following sections I'll talk about some of the things that I've implemented.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Application</h2>
<p>This class contains the main loop of the program, which at the moment doesn't include much.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Application::run()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span> (!window-&gt;isClosed())</div>
<div class="line">    {</div>
<div class="line">        onUpdate();</div>
<div class="line">        window-&gt;onUpdate();</div>
<div class="line">        <span class="comment">//    drawFrame();</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>It currently calls two update functions. The window onUpdate function just calls glfwPollEvents and the application onUpdate isn't implemented yet.</p>
<p>It also features an onEvent function which receives events from the GLFWwindow. This function is getting passed as a callback function to the window class.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Application::onEvent(Event &amp;event)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (event.type)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> Event::Type::Keyboard: {</div>
<div class="line">        <span class="keyword">auto</span> data = std::get&lt;Event::Keyboard&gt;(event.data);</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;KeyboardEvent: keycode={}, action={}&quot;</span>, data.keycode, data.action);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">case</span> Event::Type::MouseMove: {</div>
<div class="line">        <span class="keyword">auto</span> data = std::get&lt;Event::MouseMove&gt;(event.data);</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;MouseMoveEvent: x={}, y={}&quot;</span>, data.xPos, data.yPos);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">case</span> Event::Type::MouseButton: {</div>
<div class="line">        <span class="keyword">auto</span> data = std::get&lt;Event::MouseButton&gt;(event.data);</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;MouseButtonEvent: button={}, action={}&quot;</span>, data.button, data.action);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">case</span> Event::Type::MouseScroll: {</div>
<div class="line">        <span class="keyword">auto</span> data = std::get&lt;Event::MouseScroll&gt;(event.data);</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;MouseScrollEvent: x={}, y={}&quot;</span>, data.xScroll, data.yScroll);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">case</span> Event::Type::Resize: {</div>
<div class="line">        <span class="keyword">auto</span> data = std::get&lt;Event::Resize&gt;(event.data);</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;ResizeEvent: width={}, height={}&quot;</span>, data.newWidth, data.newHeight);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">case</span> Event::Type::Close: {</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;CloseEvent&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This simple system will probably work fine for everything we need. In the future we might need to forward the events to the gui, but that can just be a method call from a gui class.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Window</h2>
<p>The window class receives a properties struct in its constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Properties</div>
<div class="line">{</div>
<div class="line">    std::string title;</div>
<div class="line">    Mode mode{Mode::Windowed};</div>
<div class="line">    <span class="keywordtype">bool</span> resizeable{<span class="keyword">false</span>};</div>
<div class="line">    <span class="keywordtype">bool</span> resized{<span class="keyword">false</span>};</div>
<div class="line">    Vsync vsync{Vsync::ON};</div>
<div class="line">    Extent extent{800, 600};</div>
<div class="line">    std::function&lt;void(Event &amp;)&gt; eventCallback;</div>
<div class="line">};</div>
</div><!-- fragment --><p>These settings are then used to initialize glfw. Because we're only going to use vulkan (and not directX for example), there is no need to abstract the window class for different operating systems. Also, we are using glfw which is cross-platform already.</p>
<p>This is also where the eventCallback gets called. This is one example.</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">glfwSetWindowSizeCallback(handle, [](GLFWwindow *window, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> *data = <span class="keyword">reinterpret_cast&lt;</span>Properties *<span class="keyword">&gt;</span>(glfwGetWindowUserPointer(window)))</div>
<div class="line">    {</div>
<div class="line">        data-&gt;extent.width = width;</div>
<div class="line">        data-&gt;extent.height = height;</div>
<div class="line">        data-&gt;resized = <span class="keyword">true</span>;</div>
<div class="line">        Event <span class="keyword">event</span>{Event::Type::Resize, Event::Resize{width, height}};</div>
<div class="line">        data-&gt;eventCallback(event);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>It uses glfwGetWindowUserPointer to get the windowData and then uses the callback which gets set in the application.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Events</h2>
<p>Events are currently just a struct with a type and data.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Event</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>Resize</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> newWidth;</div>
<div class="line">        <span class="keywordtype">int</span> newHeight;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum class</span> Type</div>
<div class="line">    {</div>
<div class="line">        Keyboard,</div>
<div class="line">        MouseMove,</div>
<div class="line">        MouseButton,</div>
<div class="line">        MouseScroll,</div>
<div class="line">        Resize,</div>
<div class="line">        Close</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Data = std::variant&lt;Keyboard, MouseMove, MouseButton, MouseScroll, Resize, Close&gt;;</div>
<div class="line"> </div>
<div class="line">    Type type;</div>
<div class="line">    Data data;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The type can then be checked in switch statement and the data can be accessed.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Input Polling</h2>
<p>Sometimes it can be helpful to poll input. Glfw provides functions to do just that. To make those functions more easily accessible the glfw functions are in the vkf namespace. As the need for more functionality arises, more functions will be added.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacevkf.html">vkf</a></div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">bool</span> isKeyPressed(GLFWwindow *window, <span class="keywordtype">int</span> keycode);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> isMouseButtonPressed(GLFWwindow *window, <span class="keywordtype">int</span> button);</div>
<div class="line"> </div>
<div class="line">std::pair&lt;double, double&gt; getMousePosition(GLFWwindow *window);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> getMouseX(GLFWwindow *window);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> getMouseY(GLFWwindow *window);</div>
<div class="line">} <span class="comment">// namespace vkf</span></div>
<div class="ttc" id="anamespacevkf_html"><div class="ttname"><a href="namespacevkf.html">vkf</a></div><div class="ttdoc">The top-level namespace for the Vulkan Framework (vkf).</div><div class="ttdef"><b>Definition</b> Event.h:17</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Logging</h2>
<p>This project uses <a href="https://github.com/gabime/spdlog">spdlog</a>. The init function gets called in the main entry point of the program. The macros can then be called to log relevant information.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ROOT_PATH_SIZE</span></div>
<div class="line"><span class="preprocessor">#define ROOT_PATH_SIZE 0</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define __FILENAME__ (static_cast&lt;const char *&gt;(__FILE__) + ROOT_PATH_SIZE)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define LOG_INFO(...) spdlog::info(__VA_ARGS__);</span></div>
<div class="line"><span class="preprocessor">#define LOG_WARN(...) spdlog::warn(__VA_ARGS__);</span></div>
<div class="line"><span class="preprocessor">#define LOG_ERROR(...) spdlog::error(&quot;[{}:{}] {}&quot;, __FILENAME__, __LINE__, fmt::format(__VA_ARGS__));</span></div>
<div class="line"><span class="preprocessor">#define LOG_DEBUG(...) spdlog::debug(__VA_ARGS__);</span></div>
</div><!-- fragment --><p>The logger gets initialized when the static init function from the Application class gets called.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Application::initLogger()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;spdlog::sink_ptr&gt; sinks;</div>
<div class="line">        sinks.push_back(std::make_shared&lt;spdlog::sinks::stdout_color_sink_st&gt;());</div>
<div class="line">        <span class="keyword">auto</span> logger = std::make_shared&lt;spdlog::logger&gt;(<span class="stringliteral">&quot;logger&quot;</span>, sinks.begin(), sinks.end());</div>
<div class="line"><span class="preprocessor">#if !defined(NDEBUG)</span></div>
<div class="line">        logger-&gt;set_level(spdlog::level::debug);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">        logger-&gt;set_level(spdlog::level::info);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        spdlog::set_pattern(<span class="stringliteral">&quot;[%^%l%$] %v&quot;</span>);</div>
<div class="line">        spdlog::set_default_logger(logger);</div>
<div class="line">        logger-&gt;info(<span class="stringliteral">&quot;Initialized logger&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> spdlog::spdlog_ex &amp;ex)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Log initialization failed: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Vulkan Hpp</h2>
<p>This project uses <a href="https://github.com/KhronosGroup/Vulkan-Hpp">vulkan.hpp</a>. This means the code will look a bit different from the standard Vulkan API. Because this project is compiled using the c++20 standard, I also use designated initializers. In order to use them you need to #define VULKAN_HPP_NO_CONSTRUCTORS. This makes the code look cleaner in my opinion. Here an example from the vulkan hpp gitHub.</p>
<div class="fragment"><div class="line"><span class="comment">// initialize the vk::ApplicationInfo structure</span></div>
<div class="line">vk::ApplicationInfo applicationInfo{</div>
<div class="line">.pApplicationName   = AppName,</div>
<div class="line">.applicationVersion = 1,</div>
<div class="line">.pEngineName        = EngineName,</div>
<div class="line">.engineVersion      = 1,</div>
<div class="line">.apiVersion         = VK_API_VERSION_1_1</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize the vk::InstanceCreateInfo</span></div>
<div class="line">vk::InstanceCreateInfo instanceCreateInfo{ .pApplicationInfo = &amp; applicationInfo };</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Dynamic Loader</h3>
<p>I'm using the Dynamic loader that vulkan-hpp provides. In order to use it, a couple of macros have to be defined.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VULKAN_HPP_DISPATCH_LOADER_DYNAMIC 1</span></div>
<div class="line"><span class="preprocessor">#define VULKAN_HPP_NO_CONSTRUCTORS</span></div>
<div class="line"> </div>
<div class="line">VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</div>
</div><!-- fragment --><p>To create it there are three steps:</p>
<div class="fragment"><div class="line">vk::DynamicLoader dl;</div>
<div class="line"><span class="keyword">auto</span> vkGetInstanceProcAddr = dl.getProcAddress&lt;PFN_vkGetInstanceProcAddr&gt;(<span class="stringliteral">&quot;vkGetInstanceProcAddr&quot;</span>);</div>
<div class="line">VULKAN_HPP_DEFAULT_DISPATCHER.init(vkGetInstanceProcAddr);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">vk::Instance instance = vk::createInstance({}, <span class="keyword">nullptr</span>);</div>
<div class="line">VULKAN_HPP_DEFAULT_DISPATCHER.init(instance);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;vk::PhysicalDevice&gt; physicalDevices = instance.enumeratePhysicalDevices();</div>
<div class="line">assert(!physicalDevices.empty());</div>
<div class="line">vk::Device device = physicalDevices[0].createDevice({}, <span class="keyword">nullptr</span>);</div>
<div class="line">VULKAN_HPP_DEFAULT_DISPATCHER.init(device);</div>
</div><!-- fragment --><p>There is a detailed explanation in the <a href="https://github.com/KhronosGroup/Vulkan-Hpp">vulkan.hpp</a> gitHub README.md.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Raii</h3>
<p>With raii you don't have to worry about cleaning up your vulkan handles. Here an example from the gitHub.</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line">vk::raii::Device device( physicalDevice, deviceCreateInfo );</div>
</div><!-- fragment --><p>This device gets destroyed automatically when it leaves its scope. There are other benefits, but also some inconveniences. All of this can be found in the <a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/vk_raii_ProgrammingGuide.mdk">raii programing guide</a>.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Vulkan Instance</h2>
<p>Instance is the first core class that I've implemented. It tries to enable all the extensions that were passed as required extensions in the constructor and sets up the debug messenger.</p>
<p>TODO: write about enabling layers and extensions</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Debug Messenger</h2>
<p>The debug messenger only gets initialized if in the debug build.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if !defined(NDEBUG)</span></div>
<div class="line">VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</div>
<div class="line">                                             VkDebugUtilsMessageTypeFlagsEXT messageTypes,</div>
<div class="line">                                             VkDebugUtilsMessengerCallbackDataEXT <span class="keyword">const</span> *callbackData,</div>
<div class="line">                                             <span class="keywordtype">void</span> * <span class="comment">/*pUserData*/</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Log debug message</span></div>
<div class="line">    <span class="keywordflow">if</span> (messageSeverity &amp; VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT)</div>
<div class="line">    {</div>
<div class="line">        LOG_WARN(<span class="stringliteral">&quot;{} - {}: {}&quot;</span>, callbackData-&gt;messageIdNumber, callbackData-&gt;pMessageIdName, callbackData-&gt;pMessage);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (messageSeverity &amp; VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)</div>
<div class="line">    {</div>
<div class="line">        LOG_ERROR(<span class="stringliteral">&quot;{} - {}: {}&quot;</span>, callbackData-&gt;messageIdNumber, callbackData-&gt;pMessageIdName, callbackData-&gt;pMessage);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> VK_FALSE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#if !defined(NDEBUG)</span></div>
<div class="line">    debugMessenger = vk::raii::DebugUtilsMessengerEXT{</div>
<div class="line">        handle, vk::DebugUtilsMessengerCreateInfoEXT{</div>
<div class="line">                    .messageSeverity = vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |</div>
<div class="line">                                       vk::DebugUtilsMessageSeverityFlagBitsEXT::eError,</div>
<div class="line">                    .messageType = vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |</div>
<div class="line">                                   vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance |</div>
<div class="line">                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation,</div>
<div class="line">                    .pfnUserCallback = &amp;debugCallback,</div>
<div class="line">                }};</div>
<div class="line">    LOG_DEBUG(<span class="stringliteral">&quot;Created debug messenger&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#if !defined(NDEBUG)</span></div>
<div class="line">    vk::StructureChain&lt;vk::InstanceCreateInfo, vk::DebugUtilsMessengerCreateInfoEXT&gt; instanceCreateInfo = {</div>
<div class="line">        vk::InstanceCreateInfo{.pApplicationInfo = &amp;applicationInfo,</div>
<div class="line">                               .enabledLayerCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(enabledLayers.size()),</div>
<div class="line">                               .ppEnabledLayerNames = enabledLayers.data(),</div>
<div class="line">                               .enabledExtensionCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(enabledExtensions.size()),</div>
<div class="line">                               .ppEnabledExtensionNames = enabledExtensions.data()},</div>
<div class="line">        vk::DebugUtilsMessengerCreateInfoEXT{</div>
<div class="line">            .messageSeverity = vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |</div>
<div class="line">                               vk::DebugUtilsMessageSeverityFlagBitsEXT::eError,</div>
<div class="line">            .messageType = vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |</div>
<div class="line">                           vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance |</div>
<div class="line">                           vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation,</div>
<div class="line">            .pfnUserCallback = &amp;debugCallback,</div>
<div class="line">        }};</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    vk::StructureChain&lt;vk::InstanceCreateInfo&gt; instanceCreateInfo = {</div>
<div class="line">        vk::InstanceCreateInfo{.pApplicationInfo = &amp;applicationInfo,</div>
<div class="line">                               .enabledLayerCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(enabledLayers.size()),</div>
<div class="line">                               .ppEnabledLayerNames = enabledLayers.data(),</div>
<div class="line">                               .enabledExtensionCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(enabledExtensions.size()),</div>
<div class="line">                               .ppEnabledExtensionNames = enabledExtensions.data()}};</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>In order to track issues that can arise during instance creation or destruction, we pass the debugUtilsCreateInfo to the pNext extensions field of instanceCreateInfo. <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/appendices/VK_EXT_debug_utils.adoc#examples">extension documentation</a></p>
<p>For this we're using vulkan-hpp structure chains. During instance creation we can get the creatInfo by simply calling</p>
<div class="fragment"><div class="line">handle = vk::raii::Instance{context, instanceCreateInfo.get&lt;vk::InstanceCreateInfo&gt;()};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md20"></a>
Results</h2>
<p>When starting the program, this is the terminal output:</p>
<p>TODO: No surface yet</p>
<p><img src="../updates/November_6_images/terminal.png" alt="not showing image" class="inline"/></p>
<p>The logger gets initialized and the layers/extensions get enabled.</p>
<p><img src="../updates/November_6_images/window.png" alt="not showing image" class="inline"/></p>
<p>The Window doesn't display anything yet but works like any other window.</p>
<p><img src="../updates/November_6_images/terminal2.png" alt="not showing image" class="inline"/></p>
<p>Events get outputted in the terminal in the Debug build at the moment, but will be used to interact with the application. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
