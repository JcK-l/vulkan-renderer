<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan Renderer: November 25 - RenderManger</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Vulkan Renderer<span id="projectnumber">&#160;v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">November 25 - RenderManger</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md2"></a> In this update I will be going over the new <code>RenderManager</code> class and how it is used to manage the rendering of the application.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Swapchain</h2>
<p>First off, the <code>Swapchain</code> class. It handles the creation and recreation of the swapchain. A bunch of default values are set in the createInfo struct</p>
<div class="fragment"><div class="line">supportDetails.formats = gpu.getHandle().getSurfaceFormatsKHR(*surface);</div>
<div class="line">supportDetails.presentModes = gpu.getHandle().getSurfacePresentModesKHR(*surface);</div>
<div class="line">supportDetails.capabilities = gpu.getHandle().getSurfaceCapabilitiesKHR(*surface);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> surfaceFormat = selectSwapSurfaceFormat();</div>
<div class="line"><span class="keyword">auto</span> presentMode = selectSwapPresentMode();</div>
<div class="line">extent = selectSwapExtent();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> preTransform = (supportDetails.capabilities.supportedTransforms &amp; vk::SurfaceTransformFlagBitsKHR::eIdentity)</div>
<div class="line">                        ? vk::SurfaceTransformFlagBitsKHR::eIdentity</div>
<div class="line">                        : supportDetails.capabilities.currentTransform;</div>
<div class="line"> </div>
<div class="line">uint32_t minImageCount =</div>
<div class="line">    std::clamp(3u, supportDetails.capabilities.minImageCount, supportDetails.capabilities.maxImageCount);</div>
<div class="line"> </div>
<div class="line">vk::CompositeAlphaFlagBitsKHR compositeAlpha;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (supportDetails.capabilities.supportedCompositeAlpha &amp; vk::CompositeAlphaFlagBitsKHR::ePreMultiplied)</div>
<div class="line">{</div>
<div class="line">    compositeAlpha = vk::CompositeAlphaFlagBitsKHR::ePreMultiplied;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (supportDetails.capabilities.supportedCompositeAlpha &amp; vk::CompositeAlphaFlagBitsKHR::ePostMultiplied)</div>
<div class="line">{</div>
<div class="line">    compositeAlpha = vk::CompositeAlphaFlagBitsKHR::ePostMultiplied;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (supportDetails.capabilities.supportedCompositeAlpha &amp; vk::CompositeAlphaFlagBitsKHR::eInherit)</div>
<div class="line">{</div>
<div class="line">    compositeAlpha = vk::CompositeAlphaFlagBitsKHR::eInherit;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    compositeAlpha = vk::CompositeAlphaFlagBitsKHR::eOpaque;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">vk::SwapchainCreateInfoKHR createInfo{</div>
<div class="line">    .surface = *surface,</div>
<div class="line">    .minImageCount = minImageCount,</div>
<div class="line">    .imageFormat = surfaceFormat.format,</div>
<div class="line">    .imageColorSpace = surfaceFormat.colorSpace,</div>
<div class="line">    .imageExtent = extent,</div>
<div class="line">    .imageArrayLayers = 1,</div>
<div class="line">    .imageUsage = vk::ImageUsageFlagBits::eColorAttachment,</div>
<div class="line">    .imageSharingMode = vk::SharingMode::eExclusive,</div>
<div class="line">    .preTransform = preTransform,</div>
<div class="line">    .compositeAlpha = compositeAlpha,</div>
<div class="line">    .presentMode = presentMode,</div>
<div class="line">    .clipped = VK_TRUE,</div>
<div class="line">    .oldSwapchain = oldSwapchain,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">handle = vk::raii::SwapchainKHR{device.getHandle(), createInfo};</div>
</div><!-- fragment --><p>Some of these might get changed later on, but for now they are fine. The <code>Swapchain</code> class also has a <code>recreate</code> method, which gets called when the window is resized. It will then recreate the swapchain with the new extent.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Swapchain::recreate()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> [width, height] = window.getFramebufferSize();</div>
<div class="line">    <span class="keywordflow">while</span> (width == 0 || height == 0)</div>
<div class="line">    {</div>
<div class="line">        std::tie(width, height) = window.getFramebufferSize();</div>
<div class="line">        window.waitEvents();</div>
<div class="line">    }</div>
<div class="line">    device.getHandle().waitIdle();</div>
<div class="line"> </div>
<div class="line">    createSwapchain(*handle);</div>
<div class="line">    LOG_INFO(<span class="stringliteral">&quot;Recreated Swapchain&quot;</span>)</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> createSwapchain(vk::SwapchainKHR oldSwapchain = VK_NULL_HANDLE);</div>
</div><!-- fragment --><p>The <code>createSwapchain</code> method can take an optional <code>oldSwapchain</code> parameter, which is used when recreating the swapchain.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
FrameData</h2>
<p>Each frame has its own <code>FrameData</code> object. This object contains the <code>CommandBuffer</code>, <code>Fence</code> and <code>Semaphores</code> for the frame.</p>
<div class="fragment"><div class="line">vk::raii::CommandBuffer *getCommandBuffer();</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">const</span> vk::raii::Semaphore &amp;getSemaphore(uint32_t index) <span class="keyword">const</span>;</div>
<div class="line">[[nodiscard]] <span class="keyword">const</span> vk::raii::Fence &amp;getFence() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>These then get used in the <code>RenderManager</code> class to get the necessary data for the current frame.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
CommandPool</h3>
<p>When the vk::raii::CommandPool gets destroyed, it will automatically free all the command buffers that were allocated. This does not include the vk::raii::CommandBuffer objects that were created from the pool. These need to be freed manually. <a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/vk_raii_ProgrammingGuide.md">vk_raii_ProgrammingGuide</a></p>
<p>The CommandPool can allocate multiple command buffers at once, but to allow more requests after the first allocation, the <code>CommandPool</code> class stores the vk::raii::CommandBuffers in an unordered map. A pointer to the vk::raii:: CommandBuffers can then be retrieved with the <code>getCommandBuffers</code> method.</p>
<div class="fragment"><div class="line">std::optional&lt;vk::raii::CommandBuffers *&gt; getCommandBuffers(uint32_t key) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The unordered map might not be the best solution, but it works for now.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Framebuffer</h2>
<p>A framebuffer is a collection of attachments used for rendering. The <code>Framebuffer</code> constructor takes a <code>RenderTarget</code>, which contains all the ImageViews(attachments) that will be used in the framebuffer.</p>
<div class="fragment"><div class="line">Framebuffer::Framebuffer(<span class="keyword">const</span> Device &amp;device, <span class="keyword">const</span> RenderPass &amp;renderPass,</div>
<div class="line">                         <span class="keyword">const</span> rendering::RenderTarget &amp;renderTarget)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;vk::ImageView&gt; imageViews;</div>
<div class="line">    imageViews.reserve(renderTarget.imageViews.size());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;imageView : renderTarget.imageViews)</div>
<div class="line">    {</div>
<div class="line">        imageViews.emplace_back(*imageView);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    handle = vk::raii::Framebuffer{device.getHandle(),</div>
<div class="line">                                   vk::FramebufferCreateInfo{</div>
<div class="line">                                       .flags = vk::FramebufferCreateFlags{},</div>
<div class="line">                                       .renderPass = *renderPass.getHandle(),</div>
<div class="line">                                       .attachmentCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(renderTarget.imageViews.size()),</div>
<div class="line">                                       .pAttachments = imageViews.data(),</div>
<div class="line">                                       .width = renderTarget.extent.width,</div>
<div class="line">                                       .height = renderTarget.extent.height,</div>
<div class="line">                                       .layers = 1,</div>
<div class="line">                                   }};</div>
<div class="line">}</div>
</div><!-- fragment --><p>The vk::raii::Framebuffer only accepts an array of vk::ImageViews, so the vk::raii::ImageViews need to be converted to vk::ImageViews.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Renderer</h2>
<p>The <code>Renderer</code> is responsible for creating drawing the scene. It takes a <code>RenderOptions</code> struct as a parameter in its constructor. This struct currently holds the clearValue and the number of subpasses. With this information a <code>RenderPass</code> with a compatible <code>RenderTarget</code> can be created.</p>
<div class="fragment"><div class="line">Renderer::Renderer(<span class="keyword">const</span> core::Device &amp;device, core::Swapchain *swapchain, RenderOptions renderOptions)</div>
<div class="line">    : device{device}, swapchain{swapchain}, renderOptions{std::make_unique&lt;RenderOptions&gt;(renderOptions)}</div>
<div class="line">{</div>
<div class="line">    createRenderTargets();</div>
<div class="line">    createRenderSubstages();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;vk::SubpassDescription&gt; subpassDescriptions(renderOptions.numSubpasses);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;vk::AttachmentReference&gt; attachments(renderOptions.numSubpasses);</div>
<div class="line">    attachments[0] = vk::AttachmentReference{0, vk::ImageLayout::eColorAttachmentOptimal};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0u; i &lt; renderOptions.numSubpasses; ++i)</div>
<div class="line">    {</div>
<div class="line">        subpassDescriptions[i].colorAttachmentCount = 1;</div>
<div class="line">        subpassDescriptions[i].pColorAttachments = attachments.data();</div>
<div class="line">        subpassDescriptions[i].pDepthStencilAttachment = <span class="keyword">nullptr</span>;</div>
<div class="line">        subpassDescriptions[i].pInputAttachments = <span class="keyword">nullptr</span>;</div>
<div class="line">        subpassDescriptions[i].pPreserveAttachments = <span class="keyword">nullptr</span>;</div>
<div class="line">        subpassDescriptions[i].pResolveAttachments = <span class="keyword">nullptr</span>;</div>
<div class="line">        subpassDescriptions[i].pipelineBindPoint = vk::PipelineBindPoint::eGraphics;</div>
<div class="line">        subpassDescriptions[i].flags = {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;vk::SubpassDependency&gt; dependencies(renderOptions.numSubpasses - 1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0u; i &lt; renderOptions.numSubpasses - 1; ++i)</div>
<div class="line">    {</div>
<div class="line">        dependencies[i].srcSubpass = i;</div>
<div class="line">        dependencies[i].dstSubpass = i + 1;</div>
<div class="line">        dependencies[i].srcStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput;</div>
<div class="line">        dependencies[i].dstStageMask = vk::PipelineStageFlagBits::eColorAttachmentOutput;</div>
<div class="line">        dependencies[i].srcAccessMask = vk::AccessFlagBits::eColorAttachmentWrite;</div>
<div class="line">        dependencies[i].dstAccessMask = vk::AccessFlagBits::eColorAttachmentWrite;</div>
<div class="line">        dependencies[i].dependencyFlags = {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    renderPass = std::make_unique&lt;core::RenderPass&gt;(device, *renderTargets[0], subpassDescriptions, dependencies);</div>
<div class="line"> </div>
<div class="line">    LOG_INFO(<span class="stringliteral">&quot;Created Renderer&quot;</span>)</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
RenderPass</h3>
<p>OpenGl has no concept of a render pass. It is possible to ommit the render pass in Vulkan using dynamic rendering, but for this project I will be using a render pass.</p>
<div class="fragment"><div class="line">RenderPass::RenderPass(<span class="keyword">const</span> core::Device &amp;device, <span class="keyword">const</span> rendering::RenderTarget &amp;renderTarget,</div>
<div class="line">                       <span class="keyword">const</span> std::vector&lt;vk::SubpassDescription&gt; &amp;subpassDescriptions,</div>
<div class="line">                       <span class="keyword">const</span> std::vector&lt;vk::SubpassDependency&gt; &amp;subpassDependencies)</div>
<div class="line">    : device{device}</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> createInfo =</div>
<div class="line">        vk::RenderPassCreateInfo{.flags = vk::RenderPassCreateFlags{},</div>
<div class="line">                                 .attachmentCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(renderTarget.attachments.size()),</div>
<div class="line">                                 .pAttachments = renderTarget.attachments.data(),</div>
<div class="line">                                 .subpassCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(subpassDescriptions.size()),</div>
<div class="line">                                 .pSubpasses = subpassDescriptions.data(),</div>
<div class="line">                                 .dependencyCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(subpassDependencies.size()),</div>
<div class="line">                                 .pDependencies = subpassDependencies.data()};</div>
<div class="line"> </div>
<div class="line">    handle = vk::raii::RenderPass{device.getHandle(), createInfo};</div>
<div class="line">    LOG_INFO(<span class="stringliteral">&quot;Created RenderPass&quot;</span>)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>RenderPass</code> class receives all the necessary create info from the <code>Renderer</code> class. This includes descriptions of all attachments that will be used, the subpass descriptions and the subpass dependencies.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
RenderTarget</h3>
<p>The <code>RenderTarget</code> is a struct that contains the extent, the imageViews and attachmentDescriptions.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>RenderTarget</div>
<div class="line">{</div>
<div class="line">    vk::Extent2D extent;</div>
<div class="line">    std::vector&lt;vk::raii::ImageView&gt; imageViews;</div>
<div class="line">    std::vector&lt;vk::AttachmentDescription&gt; attachments;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This information gets used when creating the <code>Framebuffer</code> and <code>RenderPass</code>.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
RenderSubstage</h3>
<p>The RenderSubstage is not doing anything at the moment. It represents a subpass that needs to be drawn. When the <code>draw</code> method of the <code>Renderer</code> is called, it will iterate over all the <code>RenderSubstages</code> and call their <code>draw</code> in turn.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Render loop</h2>
<p>Every Frame the <code>RenderManager</code> will call the methods <code>beginFrame</code>, <code>beginRenderPass</code> ,<code>draw</code>, <code>endRenderPass</code> and <code>endFrame</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderManager::beginFrame()</div>
<div class="line">{</div>
<div class="line">    device.getHandle().waitForFences(*frameData[activeFrame]-&gt;getFence(), VK_TRUE,</div>
<div class="line">                                     std::numeric_limits&lt;uint64_t&gt;::max());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> [result, value] = swapchain-&gt;acquireNextImage(frameData[activeFrame]-&gt;getSemaphore(0));</div>
<div class="line">    <span class="keywordflow">switch</span> (result)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> vk::Result::eSuccess:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> vk::Result::eSuboptimalKHR:</div>
<div class="line">        LOG_DEBUG(<span class="stringliteral">&quot;Acquired next image: {} (suboptimal)&quot;</span>, value)</div>
<div class="line">        <span class="keywordflow">if</span> (recreateSwapchain())</div>
<div class="line">            value =</div>
<div class="line">                swapchain-&gt;acquireNextImage(vk::raii::Semaphore{device.getHandle(), vk::SemaphoreCreateInfo{}}).second;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        LOG_ERROR(<span class="stringliteral">&quot;Acquired next image: {} (error)&quot;</span>, value)</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;Failed to acquire next image&quot;</span>};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    imageIndex = value;</div>
<div class="line">    activeCommandBuffer = frameData[activeFrame]-&gt;getCommandBuffer();</div>
<div class="line"> </div>
<div class="line">    frameActive = <span class="keyword">true</span>;</div>
<div class="line">    device.getHandle().resetFences(*frameData[activeFrame]-&gt;getFence());</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>beginFrame</code> will first wait for the fence to be signaled. This fence gets signaled when the frame is finished. It will then acquire the next image from the swapchain. If the swapchain is suboptimal, it will recreate the swapchain. Finally, it will reset the fence and set the <code>frameActive</code> flag to true.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderManager::endFrame()</div>
<div class="line">{</div>
<div class="line">    assert(frameActive &amp;&amp; <span class="stringliteral">&quot;Frame not active&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> presentQueue = device.getQueueWithFlags(0, vk::QueueFlagBits::eGraphics).getHandle();</div>
<div class="line">    vk::PipelineStageFlags waitStages[] = {vk::PipelineStageFlagBits::eColorAttachmentOutput};</div>
<div class="line">    presentQueue.submit(vk::SubmitInfo{.waitSemaphoreCount = 1,</div>
<div class="line">                                       .pWaitSemaphores = &amp;*frameData[activeFrame]-&gt;getSemaphore(0),</div>
<div class="line">                                       .pWaitDstStageMask = waitStages,</div>
<div class="line">                                       .commandBufferCount = 1,</div>
<div class="line">                                       .pCommandBuffers = &amp;*(*activeCommandBuffer), </div>
<div class="line">                                       .signalSemaphoreCount = 1,</div>
<div class="line">                                       .pSignalSemaphores = &amp;*frameData[activeFrame]-&gt;getSemaphore(1)},</div>
<div class="line">                        *frameData[activeFrame]-&gt;getFence());</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> result =</div>
<div class="line">        presentQueue.presentKHR(vk::PresentInfoKHR{.waitSemaphoreCount = 1,</div>
<div class="line">                                                   .pWaitSemaphores = &amp;*frameData[activeFrame]-&gt;getSemaphore(1),</div>
<div class="line">                                                   .swapchainCount = 1,</div>
<div class="line">                                                   .pSwapchains = &amp;*swapchain-&gt;getHandle(),</div>
<div class="line">                                                   .pImageIndices = &amp;imageIndex,</div>
<div class="line">                                                   .pResults = <span class="keyword">nullptr</span>});</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (window.isResized())</div>
<div class="line">    {</div>
<div class="line">        recreateSwapchain();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (result)</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> vk::Result::eSuccess:</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> vk::Result::eSuboptimalKHR:</div>
<div class="line">            LOG_DEBUG(<span class="stringliteral">&quot;Presented image: {} (suboptimal)&quot;</span>, activeFrame)</div>
<div class="line">            recreateSwapchain();</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> vk::Result::eErrorOutOfDateKHR:</div>
<div class="line">            LOG_DEBUG(<span class="stringliteral">&quot;Presented image: {} (out of date)&quot;</span>, activeFrame)</div>
<div class="line">            recreateSwapchain();</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            LOG_ERROR(<span class="stringliteral">&quot;Presented image: {} (error)&quot;</span>, activeFrame)</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;Failed to present image&quot;</span>};</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    frameActive = <span class="keyword">false</span>;</div>
<div class="line">    activeFrame = activeFrame++ % framesInFlight;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>endFrame</code> will first submit the command buffer to the queue. It will then present the image to the swapchain.</p>
<p>At the end of the frame, the <code>frameActive</code> flag is set to false and the <code>activeFrame</code> is incremented. Active frame is the index of the frameData that is currently being used. This index is used to get the correct frameData object. This is seperate from the imageIndex, which is the index of the image in the swapchain.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderManager::beginRenderPass()</div>
<div class="line">{</div>
<div class="line">    assert(frameActive &amp;&amp; <span class="stringliteral">&quot;Frame not active&quot;</span>);</div>
<div class="line">    activeCommandBuffer-&gt;reset(vk::CommandBufferResetFlagBits::eReleaseResources);</div>
<div class="line">    activeCommandBuffer-&gt;begin(vk::CommandBufferBeginInfo{.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit});</div>
<div class="line">    vk::RenderPassBeginInfo renderPassBeginInfo{.renderPass = *renderPass-&gt;getHandle(),</div>
<div class="line">                                                .framebuffer = *framebuffers[imageIndex]-&gt;getHandle(),</div>
<div class="line">                                                .renderArea = vk::Rect2D{{0, 0}, swapchain-&gt;getExtent()},</div>
<div class="line">                                                .clearValueCount = 1,</div>
<div class="line">                                                .pClearValues = renderer-&gt;getClearValue()};</div>
<div class="line"> </div>
<div class="line">    activeCommandBuffer-&gt;beginRenderPass(renderPassBeginInfo, vk::SubpassContents::eInline);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> RenderManager::endRenderPass()</div>
<div class="line">{</div>
<div class="line">    assert(frameActive &amp;&amp; <span class="stringliteral">&quot;Frame not active&quot;</span>);</div>
<div class="line">    activeCommandBuffer-&gt;endRenderPass();</div>
<div class="line">    activeCommandBuffer-&gt;end();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> RenderManager::draw()</div>
<div class="line">{</div>
<div class="line">    assert(frameActive &amp;&amp; <span class="stringliteral">&quot;Frame not active&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>begin and end render pass are pretty self-explanatory. The <code>draw</code> method is empty for now, but it will be used to draw the scene.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> RenderManager::recreateSwapchain()</div>
<div class="line">{</div>
<div class="line">    swapchain-&gt;recreate();</div>
<div class="line"> </div>
<div class="line">    renderer-&gt;updateRenderTargets();</div>
<div class="line"> </div>
<div class="line">    createFramebuffers();</div>
<div class="line">    window.setResized(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Recreating the swapchain also means recreating the framebuffers. This is done in the <code>recreateSwapchain</code> method.</p>
<p>The final loop looks like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Application::onUpdate()</div>
<div class="line">{</div>
<div class="line">    renderManager-&gt;beginFrame();</div>
<div class="line">    renderManager-&gt;beginRenderPass();</div>
<div class="line"> </div>
<div class="line">    renderManager-&gt;draw();</div>
<div class="line"> </div>
<div class="line">    renderManager-&gt;endRenderPass();</div>
<div class="line">    renderManager-&gt;endFrame();</div>
<div class="line">}</div>
</div><!-- fragment --><p>In <code>draw</code> the scene will be drawn. This will be done in the next update.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Results</h2>
<p>The application is now blue. The clear color is set to blue in the <code>RenderOptions</code> struct.</p>
<p><img src="../updates/11_25_images/application.png" alt="not showing image" class="inline"/></p>
<p>Logging also correctly shows the swapchain being recreated when the window is resized.</p>
<p><img src="../updates/11_25_images/terminal.png" alt="not showing image" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
